Προγραμματισμός Συστήματος Εργασία 2 Εαρινό Εξάμηνο 2023-2024

Ονοματεπώνυμο: Ορφέας Ηλιάδης-Σιβρής
Αριθμός Μητρώου: 1115202000057

Περιγραφή Κώδικα - Υλοποίησης

Compilation/Execution:

Makefile: Η εργασία κάνει compile με "make" ή "make all". Μπορούν να γίνουν ξεχωριστά compile τα modules με "make jobCommander" και "make jobExecutorServer".
Διαγράφή των εκτελέσιμων με: "make clean"




Αρχεία queue.c , queue.h : Υλοποιήθηκε μια δομή τριπλέτας η οποία περιέχει την δουλεία (job) ως string, 
το job ID επίσης ως string και έναν ακέραιο που περιγράφει τον file descriptor του socket με το οποίο επικοινωνεί
ο server με τον πελάτη που ανέθεσε (issued) την δουλεία. Για την δομή της τριπλέτας δημιουργήθηκαν συνάρτήσεις αρχικοποίησης 
και καταστροφής (triplet_create και triplet_destroy). Υλοποιήθηκε μια δομή κόμβου ουράς που αποτελείται από έναν δείκτη σε τριπλέτα
και έναν δείκτη στον επόμενο κόμβο της ουράς. Επιπλέον υλοποιήθηκε μια δομή ουράς που αποτελείται από έναν front και rear (δείκτη σε) κόμβο
και από έναν ακέραιο που περιγράφει το μέγεθος (πλήθος κόμβων) της ουράς. Τελος, δημιουργήθηκαν συναρτήσεις αρχικοποίησης και 
καταστροφής ουράς (queue_create, queue_destroy), συνάρτηση εισαγωγής τριπλέτας στο πίσω άκρο της ουράς (queue_insert_rear), 
συνάρτηση εξαγωγής της τριπλέτας από το εμπρός άκρο της ουράς (queue_remove_front) και συνάρτηση εξαγωγής τριπλέτας με συγκεκριμένο 
jobID (queue_remove_jobID), η οποία επιστρέφει την τριπλέτα αν βρεθεί και NULL αν δεν βρεθεί τριπλέτα με το δοθέν jobID.




Αρχείο jobCommander.c : O jobCommander έχει διάρκεια ζωής μιας εντολής, την οποία διαβάζει από τις παραμέτρους κλήσης, αρχικοποιεί μία σύνδεση
με τον server και στέλνει την εντολή. Έπειτα διαβάζει την απάντηση του server και την εκτυπώνει. Αν η εντολή είναι issueJob τότε λαμβάνει και 
εκτυπώνει και την έξοδο της δουλείας που ανέθεσε. Αρχικα ελέγχεται αν το πλήθος τών ορισμάτων κλήσης είναι έγκυρο (δηλαδη τουλαχιστον 4)
και αν δεν είναι εκτυπώνει μήνυμα λάθους και τερματίζει. Στην συνέχεια αποθηκεύει το όνομα του host και τον αριθμό του port απο τα ορίσματα κλήσης.
Αρχικοποιεί έναν ακέραιο για τον file descriptor του socket, μια δομή sockaddr_in για να κάνει bind το socket στο κατάλληλο port και την κατάλληλη 
διεύθυνση. Αρχικοποιεί το socket και θέτει τα κάτάλληλα options για αν μπορεί να επαναχρησιμοποιηθεί το port. Κάνει resolve το όνομα του host (με
gethostbyname() ) και κάνει bind το socket στην διεύθυνση και το port. Έπειτα αρχικοποιεί επικοινωνία με τον server (με την χρήση της συνάρτησης
connect() ) και γράφει στο socket το command id, ανάλογα με το ποία είναι η εντολή που έχει δοθεί, και τα υπόλοιπα ορίσματα (αν υπάρχουν).
Αν έχει δοθεί μη έγκυρη εντολή εκτυπώνει μήνυμα λάθους και τερματίζει. Στην συνέχεια κάνει shutdown (με την συνάρτηση shutdown() ) το γράψιμο στο
socket αφού ο πελάτης έστειλε το πλήρες "αίτημα" στον server. Δεσμεύει δυναμικά έναν buffer για να διαβάσει την απάντηση του 
executor-server από το socket. Αφού διαβάσει την πλήρη απάντηση την εμφανίζει στον χρήστη (έαν η εντολή ήταν issueJob διαβάζει και εμφανίζει
και το output της δουλείας μόλις ολοκληρωθεί η εκτέλεση της). Τέλος κλείνει το socket, αποδεσμεύει τον buffer και ολοκληρώνει την εκτέλεση του.





Αρχείο jobExecutorServer.c : O jobExecutorServer είναι μια πολυνηματική (multi-threaded) εφαρμογή η οποία δέχεται αιτήματα από πελάτες διαδικτύου
διαχειρίζεται κάθε αίτημα ξεχωριστά και απαντάει στον κάθε πελάτη αναλόγως, ενώ ταυτόχρονα εκτελεί και επιστρέφει την έξοδο από δουλείες που ανέθετουν
οι πελάτες (μέσω της issue job). Υπάρχουν 3 ειδών threads: Το main thread, τα controller threads και τα worker threads.


-Main Thread: Το main thread είναι το αρχικό thread που ξεκινάει να εκτελείται όταν ξεκινάει η εκτέλεση της εφαρμογής. Αρχικά ελέγχει αν τα ορίσματα
κλήσης είναι σωστά σε πλήθος και αν δεν είναι εκτυπώνει μηνυμα λάθος και ολοκληρώνει. Αποθηκεύει σε μεταβλητές, το μέγεθους του buffer (της ουράς) 
και τον αριθμό port. Αρχικοποιεί μια δομή ουράς για buffer. Αρχικοποιείται ένα βασικό socket που δέχεται συνδέσεις απο πελάτες και θέτονται τα κατάλληλα
options για αν μπορεί να επαναχρησιμοποιηθεί το port. Στην συνέχεια γίνεται bind το socket στο port και στην διεύθυνση (INADDR_ANY) και καλείται η listen()
στο socket ώστε να μπορεί το thread να "ακούσει" για συνδέσεις από πελάτες στο διαδίκτυο. Έπειτα αποθηκεύεται ο αριθμός των worker threads σε μια μεταβλητή,
δημιουργούνται τόσα worker threads (με την pthread_create) και  αποθηκεύονται σε έναν πίνακα. Εν συνέχεια ξεκινάει ένας βρόχος επανάληψης ο οποίος 
εκτελείται μέχρι η global μεταβλητή exit_received να γίνει true πράγμα που συμβαίνει αν ληφθεί απο κάποιον πελάτη η εντολή exit. Εντος του βρόχου
αρχικοποείται μια δομή για να μεταφέρονται κάποιες παράμετροι στα controller threads οι οποίες είναι: 1) το file descriptor του αρχικού socket, 2)
το file descriptor του socket για την επικοινωνία με τον πελάτη που το controller thread εξυπηρετεί και 3) το μέγιστο μέγεθος (μήκος) του buffer (ουράς).
Κατοπιν καλείται η accept η οποία περιμένει για σύνδεση πελατών στο socket. Μόλις συνδεθεί καποιος πελάτης αρχικοποιείται η δομή thread_args και 
δημιουργείται ένα νέο controller thread που παίρνει αυτά τα arguments και αναλαμβάνει την εξυπηρέτηση του συγκεκριμένου πελάτη. Παράλληλα τα controller
threads αποθηκεύονται σε έναν δυναμικά δεσμευόμενο πίνακα του οποίου το μεγεθός αυξάνεται κάθε φορά που συνδέεται ένας νέος πελάτης. Όταν δοθεί το 
exit από κάποιον πελάτη και τελειώσει ο βρόχος το main thread περιμένει να ολοκληρώσουν την εκτέλεση τους όλα τα controller και worker threads. Τέλος το
main thread αποδεσμεύει τον buffer, καταστρέφει τα mutexes για τα κοινά resources και ολοκληρώνει την εκτέλεση του.

-Controller Threads: To controller thread έχει διάρκεια ζωής μιας εντολής, δηλαδή διαβάζει την εντολή ενός πελάτη, κάνει τις απαραίτητες διεργασίες 
και επιστρέφει την απάντηση στον πελάτη ολοκληρώνοτνας την εκτέλεσή του. Αρχικά διαβάζει τις παραμέτρους σε μια δομή thread_args για να είναι προσπελάσιμες.
Εν συνεχεία διαβάζει το command id και ανάλογα με το ποία τιμή έχει πρόκειται για την αντίστοιχη εντολη. Αν το command id είναι 1, τότε 
η εντολή που δόθηκε από τον πελάτη είναι η issueJob. Σε αυτήν την περίπτωση διαβάζεται δυναμικά η δουλειά από το socket. Έπειτα αν ο buffer (ουρά) είναι
γεμάτος τότε το controller thread περιμένει στην μεταβλητή συνθήκης (condition variable) που ελέγχει αν υπάρχει χώρος στον buffer να αποθηκευθεί η
νέα δουλειά. Στην συνέχεια ανατίθεται στην νέα δουλεία μοναδικό jobID και δημιουργείται μια τριπλέτα για την δουλεία η οποία εισάγεται στον buffer. Αν 
ο buffer ήταν άδειος πριν εισαχθεί η δουλειά τότε στέλνεται signal στην μεταβλητή συνθήκης (condition variable) που ξυπνάει το worker thread όταν ικανοποιείται 
μια από τις 2 συνθήκες που απαιτούνται (είτε ο buffer γίνει non-empty, είτε το running γίνει μικρότερο από το concurrency). Τέλος το controller thread στέλνει την 
απάντηση στον πελάτη. Κατα την επεξεργασία ή τροποποίηση οποιουδήποτε κοινού(shared) resource χρησιμοποιούνται mutexes για αποφυγή τυχόν race conditions. Αν το command id 
είναι 2, τότε η εντολή που δόθηκε από τον πελάτη είναι η setConcurrency. Τότε τροποποιείται καταλλήλως το concurrency και αποστέλλεται η απάντηση στον πελάτη. Αν το command id
έιναι 3 τότε η εντολή που δόθηκε από τον πελάτη είναι stop. Σε αυτήν την περίπτωση διαβάζεται το jobID προς διαγραφή από το socket. Αν υπήρχε στον buffer δουλειά με 
αυτό το id τότε αφαιρείται και αν ο buffer ήταν προηγουμένως γεμάτος γίνεται singal η μεταβλητή συνθήκης (condition variable) που ελέγχει αν ο buffer είναι γεμάτος, έτσι 
ώστε να ξυπνήσει κάποιο controller thread που περιμένει να αναθέσει καινούργια δουλειά (αν υπάρχει τέτοιο thread). Τέλος αποστέλλεται απάντηση στον πελάτη ανάλογα
με το αν βρέθηκε δουλεία με το δοθεν id στον buffer ή όχι. Αν το command id έιναι 4 τότε η εντολή που δόθηκε από τον πελάτη είναι poll. Σε αυτήν την περίπτωση γίνεται
προσπέλαση του buffer και κάθε δουλεία σε αυτόν (μαζί με το jobID της) γράφεται στο socket για αν σταλθεί ως απάντηση στον πελάτη. Τέλος αν το command id έιναι 5
τότε η εντολή που δόθηκε από τον πελάτη είναι exit. Για κάθε δουλεία που είναι στον buffer στέλνεται στο αντίστοιχο socket ότι ο server ολοκλήρωσε 
την εκτέλεσή του πριν προλάβει να εκτελεστεί η δουλειά, ενώ ενημερώνεται με μήνυμα και ο πελάτης που έστειλε το exit. Αφού η μεταβλητή exit_received
γίνει true, καλείται η shutdown για διαβασμα στο αρχικό socket πράγμα που κάνει την accept στο main thread να αποτύχει και τον βρόχο να σπάσει. Τέλος
ξυπνάει όλα τα worker threads και τα άλλα controller threads ώστε να ολοκληρώσουν και αυτά με την σειρά τους την εκτέλεσή τους.

-Worker Threads: Τα worker threads δημιουργούνται από το main thread και ολοκληρώνουν την εκτέλεση τους όταν σταλθεί η εντολή exit. Αρχικά αν ο 
buffer είναι άδειος , δηλαδή δεν υπάρχει καμία δουλειά προς εκτέλεση, ή τρέχουν οι μέγιστες δουλείες που επιτρέπει το concurrency, το worker thread περιμένει 
στην μεταβλητή συνθήκης (condition variable) μέχρι εισαχθεί κάποια νέα δουλειά στον buffer ή να το επιτρέψει το concurrency. Αν ήρθε εντολή exit όσο βρισκόταν σε αναμονή, 
σπάει ο βρόχος και το thread ολοκληρώνει την εκτελεσή του. Το thread αφαιρεί την πρώτη δουλεία απο την ουρά (buffer) για να την εκτελέσει. Αν ο buffer ήταν προηγουμένως γεμάτος
τότε μετα την εξαγωγή της πρώτης δουλείας γίνεται signal η μεταβλητή συνθήκης που αφορά γεμάτο buffer, έτσι ώστε να ξυπνήσει κάποιο controller thread
που περιμένει να αναθέσει νέα δουλειά (αν υπάρχει τέτοιο). Εν συνεχεία, το worker thread κάνει fork. Το child proccess που προκύπτει (το οποίο
είναι αντίγραφο μόνο του συγκεκριμένου worker thread και όχι όλου του server) κάνει ανακατεύθυνση του standard output του σε ένα αρχείο της μορφής 
"pid.output" και στην συνέχεια κάνει exec με σκοπό να εκτελέσει το job. Το parent proccess, δηλαδή το worker thread αυξάνει την μεταβλητή "running"
όσο εκτελείται το child proccess και στην συνέχεια κάνει waitpid για να περιμένει για το child proccess, δηλαδη το job, να ολοκληρώσει την εκτελεσή του 
και μόλις γίνει μειώνει την μεταβλητή "running" κατα 1.
Τέλος το worker thread δημιουργεί strings που θα οριοθετούν το output της δουλειάς, διαβάζει δυναμικά το output απο το αρχείο και το στέλνει στον
πελάτη που ανέθεσε την δουλειά.



Σχόλια/Συμβάσεις: 

    -Όταν ο server λάβει exit, εκτός από το μήνυμα που στέλνει σε όλους του πελάτες που έχουν αναθέσει δουλειά που δεν πρόλαβε να εκτελεστεί, στέλνει 
    απάντηση "SERVER TERMINATED" και στον ίδιο τον πελάτη που έστειλε το exit .
    
    -Όταν αφαιρείται από τον buffer ένα job λόγω μιας εντολής stop, τότε αποστέλλεται "JOB REMOVED" και στον πελάτη που έστειλε την stop και στον
    πελάτη που ανέθεσε την δουλειά.

    -Η απάντηση "JOB SUBMITED" που στέλνεται πίσω στους πελάτες όταν αναθέτουν μια δουλεία επιτυχώς, εκτυπώνεται από τον πελάτη μόλις ληφθεί και 
    η πλήρης έξοδος της δουλειάς και κλείσει το socket (και άρα η επικοινωνία) από το οποίο διάβαζε ο πελάτης την απάντηση του server.




Testing:

    Στον φάκελο "tests" βρίσκονται τα ενδεικτικά test της 1ης εργασίας, τροποποιημένα στις ανάγκες της 2ης.
    Οι jobCommanders παίρνουν ως serverName το linux05.di.uoa.gr, πράγμα που σημαίνει ότι ο jobExecutorServer πρέπει να τρέχει στο συγκεκριμένο
    μηχάνημα, προκειμένου να μπορούν να τρέξουν τα test (σωστά). Συγκεκριμένα οι δοκιμές που έγιναν για την ορθότητα της εκτέλεσης των προγραμμάτων 
    είναι η εξής: 

        1. Τρέχει ο jobExecutorServer στο linux05.di.uoa.gr με την εντολή ./jobExecutorServer 12345 bufferSize workerNum εντός του καταλόγου bin,
        όπου στις δοκιμές χρησιμοποιήθηκε bufferSize = 2, 4, 8 και workerNum = 4, 5.
        2. Τρέχει κάποιο test σε κάποιο άλλο linux μηχάνημα με την εντολη ./test_jobExecutor_X.sh , εντός του καταλόγου tests, όπου προφανώς
        Χ = 1,2,3,...,8. 
    
    -Σημείωση: Μετά την εκτέλεση κάθε test, πρέπει να ξανατρέξει η διεργασία του jobExecutorServer, διότι κάθε script στο τέλος 
    στέλνει την εντολή "exit".
